# Main HTTP server block - Redirects all HTTP traffic to HTTPS
server {
    listen 80;
    server_name appf4.io.vn;

    # Allow Let's Encrypt ACME challenge
    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }

    # Redirect all HTTP traffic to HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}
# Keycloak server block
server {
    listen 443 ssl;
    server_name keycloak.appf4.io.vn;

    # SSL configuration
    ssl_certificate /etc/letsencrypt/live/appf4.io.vn/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/appf4.io.vn/privkey.pem;

    location = /realms/jhipster/protocol/openid-connect/token {
        proxy_pass http://keycloak:9080;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_http_version 1.1;
        proxy_request_buffering off;
    }

    # All other routes
    location / {
        proxy_pass http://keycloak:9080;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

}
# Redis server block
server {
    listen 443 ssl;
    server_name redis.appf4.io.vn;

    # SSL configuration
    ssl_certificate /etc/letsencrypt/live/appf4.io.vn/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/appf4.io.vn/privkey.pem;

    location / {
        proxy_pass http://redis:6379;
        proxy_set_header Host redis:6379;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
    }
}
# Kafdrop server block with Keycloak authentication
server {
    listen 443 ssl;
    server_name kafdrop.appf4.io.vn;

    # SSL configuration
    ssl_certificate /etc/letsencrypt/live/appf4.io.vn/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/appf4.io.vn/privkey.pem;

    # DNS resolver for OpenID Connect
    resolver 8.8.8.8 ipv6=off;

    location / {
        # OpenID Connect authentication
        access_by_lua_block {
            local opts = {
                redirect_uri = "https://kafdrop.appf4.io.vn/oauth2/callback",
                discovery = "https://keycloak.appf4.io.vn/realms/jhipster/.well-known/openid-configuration",
                client_id = "web_app",
                client_secret = "0TnpRknqjQYngbnbRW7hKECA8TbR4D7V",
                scope = "openid email profile",
                ssl_verify = "no"
            }
            local res, err = require("resty.openidc").authenticate(opts)
            if err then
            ngx.status = 403
            ngx.say(err)
            ngx.exit(ngx.HTTP_FORBIDDEN)
            end
        }

        # Proxy configuration
        proxy_pass http://kafka-ui:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
# Consul server block with Keycloak authentication
server {
    listen 443 ssl;
    server_name consul.appf4.io.vn;

    ssl_certificate /etc/letsencrypt/live/appf4.io.vn/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/appf4.io.vn/privkey.pem;

    # Docker DNS resolver
    resolver 127.0.0.11 ipv6=off;

    location / {
        access_by_lua_block {
            local my_secret = "f4security"

            -- 1. WHITELIST: Allow Health Checks & Service Discovery
            -- /v1/status/leader and /v1/catalog/services
            if ngx.var.uri == "/v1/status/leader"
            or ngx.var.uri == "/v1/catalog/services" then
            return
            end

            -- 2. Check Headers
            local headers = ngx.req.get_headers()
            local header_token = headers["x-consul-token"]

            -- 3. Check URL
            local args = ngx.req.get_uri_args()
            local query_token = args["token"]

            -- 4. BYPASS LOGIC (Secrets)
            if (header_token == my_secret) or (query_token == my_secret) then
            if header_token then
            ngx.req.clear_header("X-Consul-Token")
            end
            return
            end

            -- 5. AUTH LOGIC (Keycloak)
            local opts = {
                redirect_uri = "https://consul.appf4.io.vn/oauth2/callback",
                discovery = "https://keycloak.appf4.io.vn/realms/jhipster/.well-known/openid-configuration",
                client_id = "web_app",
                client_secret = "0TnpRknqjQYngbnbRW7hKECA8TbR4D7V",
                scope = "openid email profile",
                ssl_verify = "no",
                refresh_session_interval = 900
            }

            local res, err = require("resty.openidc").authenticate(opts)

            if err then
            ngx.status = 403
            return ngx.exit(ngx.HTTP_FORBIDDEN)
            end
        }

        proxy_pass http://consul:8500;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Authorization $http_authorization;
    }
}

# RedisInsight server block with Keycloak authentication
server {
    listen 443 ssl;
    server_name redisinsiight.appf4.io.vn;

    # SSL configuration
    ssl_certificate /etc/letsencrypt/live/appf4.io.vn/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/appf4.io.vn/privkey.pem;

    # DNS resolver for OpenID Connect
    resolver 8.8.8.8 ipv6=off;

    location / {
        # OpenID Connect authentication
        access_by_lua_block {
            local opts = {
                redirect_uri = "https://redisinsiight.appf4.io.vn/oauth2/callback",
                discovery = "https://keycloak.appf4.io.vn/realms/jhipster/.well-known/openid-configuration",
                client_id = "web_app",
                client_secret = "0TnpRknqjQYngbnbRW7hKECA8TbR4D7V",
                scope = "openid email profile",
                ssl_verify = "no"
            }
            local res, err = require("resty.openidc").authenticate(opts)
            if err then
            ngx.status = 403
            ngx.say(err)
            ngx.exit(ngx.HTTP_FORBIDDEN)
            end
        }

        # Proxy configuration
        proxy_pass http://redisinsight:5540;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

# Vault server block with Keycloak authentication
server {
    listen 443 ssl;
    server_name vault.appf4.io.vn;

    ssl_certificate /etc/letsencrypt/live/appf4.io.vn/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/appf4.io.vn/privkey.pem;

    location / {
        proxy_pass http://vault:8200;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
    }
}
# ================================
# Grafana + OIDC (Keycloak)  ← THÊM MỚI
# ================================
server {
    listen 443 ssl;
    server_name grafana.appf4.io.vn;

    ssl_certificate /etc/letsencrypt/live/appf4.io.vn/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/appf4.io.vn/privkey.pem;

    # resolver 8.8.8.8 ipv6=off;

    location / {
        # access_by_lua_block {
        #     local opts = {
        #         redirect_uri = "https://grafana.appf4.io.vn/oauth2/callback",
        #         discovery = "https://keycloak.appf4.io.vn/realms/jhipster/.well-known/openid-configuration",
        #         client_id = "web_app",
        #         client_secret = "0TnpRknqjQYngbnbRW7hKECA8TbR4D7V",
        #         scope = "openid email profile",
        #         ssl_verify = "no"
        #     }
        #     local res, err = require("resty.openidc").authenticate(opts)
        #     if err then
        #     ngx.status = 403
        #     ngx.say(err)
        #     ngx.exit(ngx.HTTP_FORBIDDEN)
        #     end
        # }

        proxy_pass http://grafana:3000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}


# upstream gkg_upstream {
#     server gkg:27496; # Docker service name + internal GKG port
#     keepalive 32;
# }
# GKG (GitLab Knowledge Graph) - MCP over HTTPS
# server {
#     listen 443 ssl http2;
#     server_name gkg.appf4.io.vn;
#     # Replace with your certs
#     ssl_certificate /etc/letsencrypt/live/appf4.io.vn/fullchain.pem;
#     ssl_certificate_key /etc/letsencrypt/live/appf4.io.vn/privkey.pem;
#     client_max_body_size 100m;
#     proxy_read_timeout 600s;
#     proxy_send_timeout 600s;
#     send_timeout 600s;
#     location / {
#         proxy_pass http://gkg_upstream;
#         proxy_http_version 1.1;
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;
#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#         proxy_set_header X-Forwarded-Proto $scheme;
#         proxy_set_header Connection "";
#         proxy_redirect off;
#     }
# }
# server {
#     listen 443 ssl;
#     server_name sms.appf4.io.vn;
#     # SSL Configuration
#     ssl_certificate /etc/letsencrypt/live/appf4.io.vn/fullchain.pem;
#     ssl_certificate_key /etc/letsencrypt/live/appf4.io.vn/privkey.pem;
#     # Common proxy headers
#     proxy_set_header Host $host;
#     proxy_set_header X-Real-IP $remote_addr;
#     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#     proxy_set_header X-Forwarded-Proto https;
#     ##############################
#     # API Gateway Configuration
#     ##############################
#     location / {
#         proxy_pass http://sms-gateway:3000;
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;